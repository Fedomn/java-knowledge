## SOLID: OOD设计原则

### S: single responsibility principle
> 应该有且只有一个原因引起类的变更, 一个类/接口应该只有一个职责

要实现单一职责,需要先把相同类型的功能抽象出来.

#### 优势:
* 类的复杂性降低,实现什么职责都有清晰明确的定义
* 可读性/维护性提高,复杂性降低.
* 变更引起的风险降低,应为接口是单一职责的,所以一个接口的修改只对相应的实现类有影响.


### O: open/closed principle
> 一个软件实体如类/模块/函数,应该对扩展开放,对修改关闭.

解析: 一个软件实体应该通过扩展来实现变化,而不是通过修改已有代码来实现变化.

### L: Liskov substitution principle
> 里氏替换原则: 所有引用基类的地方必须能透明地使用其子类的对象.

解析: 只要父类能出现的地方,子类就能出现,而且替换为子类也不会产生任何错误或异常.
使用者可能根本不需要知道是父类还是子类,但是,反过来就不行了,有子类出现的地方,父类未必就能适应.

里氏替换原则是实现开闭原则的重要方式之一,程序中尽量使用基类来对对象进行定义,而在其运行的时候传递给它的是其子类类型,
而不需要修改原来代码就进行了扩展.

实践: 一般把父类设计成抽象类或接口,让子类实现父类或接口.运行时,传递的是子类,这样我们可以很方便的扩展功能,同时不需要修改原型代码,
增加新功能可以通过 增加新的子类来实现, 从而实现了开闭原则.


### I: Interface segregation principle
> 接口隔离原则: 客户端不应该依赖它不需要的接口.类间的依赖关系应该建立在最小的接口上.

解析: 把不需要的接口剔除掉,对接口进行细化,保证其纯洁性.
单一职责原则要求的是类和接口职责单一,注重的是职责,这是业务逻辑上的划分.
接口隔离原则要求接口的方法尽量少.接口要高内聚(提高其处理能力,减少对外的交互.这种不关心其怎么处理,立即完成任务的行为就是高内聚的表现)

### D: Dependency inversion principle
> 依赖倒置原则: 高层模块不应该依赖低层模块,两者都应该依赖其抽象;抽象不应该依赖细节;细节应该依赖抽象.

解析: 每一逻辑的实现都是由原子逻辑组成的,不可分割的原子逻辑就是低层模块,原子逻辑的再组装就是高层模块.
抽象指的是接口或抽象类.细节指的是抽象产生的类.

实践: 针对抽象编程,而不是针对实现编程.
我们在程序中参数,尽量引用其抽象类. 即使用抽象类和接口来进行声明, 而不要使用具体的类来做这些事情.</br>
引入抽象层后,系统在扩展时具有很好的灵活性,只要对其抽象层进行扩展.